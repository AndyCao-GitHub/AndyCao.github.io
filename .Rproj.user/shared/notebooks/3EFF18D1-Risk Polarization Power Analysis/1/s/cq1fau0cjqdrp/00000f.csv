"0","#taken from my previous work"
"0","calc_group_divergence <- function(vec, midpoint = 6, scale_range = 11){"
"0","   "
"0","   X_high <- mean(vec[vec >= midpoint], na.rm = TRUE)"
"0","   if(sum(vec[vec >= midpoint], na.rm =T ) == 0){"
"0","      X_high <- 0"
"0","   }"
"0","   "
"0","   X_low <-  mean(vec[vec < midpoint], na.rm = TRUE)"
"0","   if(sum(vec[vec < midpoint], na.rm =T ) == 0){"
"0","      X_low <- 0"
"0","   }"
"0","   return((abs(X_high - X_low)/ scale_range))"
"0","}"
"0",""
"0",""
"0","calc_bimodality_coefficient <- function(vec){"
"0","   skew <- skew(vec, na.rm = TRUE, type = 3)"
"0","   kurtosis <- kurtosi(vec, na.rm = TRUE, type = 3)"
"0","   n <- sum(!is.na(vec))"
"0","   return((skew^2+1) / (kurtosis + ((3*((n-1))^2)/((n-2)*(n-3))) ))"
"0","}"
"0",""
"0","# Created this one ""from scratch"", as we work with a smaller scale of 11 instead of 101, the calculation of polarization does not take too long anymore"
"0",""
"0","calc_polarization <- function(vec){"
"0","   vec2 <- as.vector(vec)"
"0","   freq_vec <- agrmt::collapse(vec2, pos = c(1:11))"
"0","   return(agrmt::polarization(freq_vec))"
"0","}"
"0",""
"0","# this code is commented, as the computation takes too long, and I hate waiting while kniting. I have saved a sepparate rds file, which will be read in instead. Readers who want to uncomment section, select the lines to uncomment and press Ctrl + Shift + C (on Windows/Linux) or Cmd + Shift + C (on macOS)"
"0",""
"0","# #apply the functions to our result matrix, therefore calculate for each drawn sample the polarization metrics"
"0","# BC_result <- apply(result[,-c(1:2)], 1, calc_bimodality_coefficient)"
"0","# sum(is.na(BC_result))"
"0","# "
"0","# group_divergence_result <- apply(result[,-c(1:2)], 1, calc_group_divergence)"
"0","# sum(is.na(group_divergence_result))"
"0","# "
"0","# # Register parallel backend with the desired number of cores"
"0","# num_cores <- detectCores()-1"
"0","# "
"0","# cl <- makeCluster(num_cores)"
"0","# registerDoParallel(cl)"
"0","# "
"0","# # Perform parallel processing using foreach, iterating through the different drawn samples"
"0","# polarization_result <- foreach(i = 1:nrow(result), .combine = rbind) %dopar% {"
"0","#   calc_polarization(result[i, -c(1:2)])"
"0","# }"
"0","# sum(is.na(polarization_result))"
"0","# "
"0","# # Stop the parallel backend"
"0","# stopCluster(cl)"
"0","# "
"0","# "
"0","# combined_result_measures <- cbind(polarization_result,"
"0","#                                   group_divergence_result,"
"0","#                                   BC_result,"
"0","#                                   result[,1:2]"
"0","#                                   )"
"0","# sum(is.na(combined_result_measures))"
"0","# "
"0","# saveRDS(combined_result_measures, ""saved_RDS\\combined_result_measures_power_analysis.rds"")"
"0",""
"0","combined_result_measures <- readRDS(""saved_RDS\\combined_result_measures_power_analysis.rds"")"
"0",""
"0","vis_miss(combined_result_measures, sort_miss = F)"
