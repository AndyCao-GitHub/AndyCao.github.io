"0","max_cols <- max(sampled)   "
"0",""
"0","# Register parallel backend with the desired number of cores"
"0","num_cores <- detectCores()-1"
"0",""
"0","cl <- makeCluster(num_cores)"
"0","registerDoParallel(cl)"
"0",""
"0","#rotate Pop_df, so our function works (each row needs to be a different distribution, instead of each col)"
"0","rot_Pop_df <- as.data.frame(t(Pop_df))"
"0",""
"0","# Define function to process each combination of risk_distribution, samplesize and replications per setting"
"0","sample_and_replicate_for_all_risks <- function(i) {"
"0","  sampled_matrix_list <- list()"
"0","  "
"0","  for (j in 1:nrow(rot_Pop_df)) {"
"0","    mat <- replicate(replications_per_setting,"
"0","                     sample(1:n_population, size = sampled[i, 1], replace = TRUE)) #create matrix of our samples with replacing, times n - replications"
"0","    "
"0","    sampled_table <- rot_Pop_df[j, mat] #using the matrix, collect the values from our risk distribution matrix (as a vector though...)"
"0","    sampled_matrix <- as.data.frame(matrix(sampled_table,"
"0","                                           nrow = replications_per_setting,"
"0","                                           ncol = sampled[i, 1],"
"0","                                           byrow = TRUE,"
"0","                                           dimnames = NULL)) #create df out of these vectors instead of flat vectors"
"0","    "
"0","    "
"0","    if (ncol(sampled_matrix) < max_cols) {"
"0","      padding_matrix <- matrix(NA,"
"0","                               nrow = nrow(sampled_matrix),"
"0","                               ncol = max_cols - ncol(sampled_matrix))"
"0","      sampled_matrix <- cbind(sampled_matrix, padding_matrix)"
"0","    } #if matrix is not wide enough for our end result matrix, padd it with NA columns, so binding rows is doable (needs same amount of ncols)"
"0","    "
"0","    sampled_matrix <- cbind(matrix(sampled[i,1], nrow = replications_per_setting), "
"0","                            matrix(j, nrow = replications_per_setting),"
"0","                            sampled_matrix) #bind columns with additional information such as sample size and which risk_distribution was sampled"
"0","    "
"0","    colnames(sampled_matrix) <- c(""sample_size"", ""risk_distribution"", paste0(""rating_"", 1:max_cols)) #rewrite colnames so it is identical to the bigh matrix"
"0","    sampled_matrix_list[[j]] <- sampled_matrix #store in list"
"0","  }"
"0","  return(do.call(rbind, sampled_matrix_list)) #after all risk distributions are sampled from, bind them all and return the output"
"0","  "
"0","}"
"0",""
"0","# Perform parallel processing using foreach, iterating through the different samplesizes"
"0","result <- foreach(i = 1:nrow(sampled), .combine = rbind) %dopar% {"
"0","  sample_and_replicate_for_all_risks(i)"
"0","}"
"0",""
"0","# Stop the parallel backend"
"0","stopCluster(cl)"
"0",""
"0","result <- mutate_all(result, as.numeric )"
"0",""
"0",""
"0","vis_miss(result[,seq(from =3, to = ncol(result), length.out = 40)], show_perc_col = F)"
